{
	//--------------------
	"Basic template": {
		"prefix": "template_basic",
		"body": [
		  "#include <bits/stdc++.h>",
		  "",
		  "using namespace std;",
		  "#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
		  "#define endl '\\n'",
		  "using ll=int64_t;",
		  "",
		  "signed main() {",
		  "    IOS int _t;cin>>_t;",
		  "    while (_t--) {",
		  "        ",
		  "    }",
		  "}"
		],
		"description": "Basic template"
	  },

	"Binary exponentiation": {
		"prefix": "maths_binexp",
		"body": [
		  "ll binexp(ll a, ll b, ll p_=1e9+7) { //log(b)",
		  "    if (!b) return 1;",
		  "    if (b%2) return a*binexp(a, b-1, p_)%p_;",
		  "    ll _=binexp(a,b>>1LL,p_);",
		  "    return _*_%p_;",
		  "}"
		],
		"description": "Binary exponentiation"
	  },

	  "Binary exponentiation (Iterative)": {
  "prefix": "maths_binexp_iterative",
  "body": [
    "long long binexp(long long a, long long b, long long m) {",
    "    a %= m;",
    "    long long res = 1;",
    "    while (b > 0) {",
    "        if (b & 1)",
    "            res = res * a % m;",
    "        a = a * a % m;",
    "        b >>= 1;",
    "    }",
    "    return res;",
    "}"
  ],
  "description": "Binary exponentiation"
},

	"Prime factorisation": {
		"prefix": "maths_factorize",
		"body": [
		  "unordered_map<ll,ll> get_divisors(ll n) { //O(sqrt(n))",
		  "    unordered_map<ll,ll> ans;",
		  "    ll _=sqrt(n);",
		  "    for (ll i=2;i<=_;i++)",
		  "        while (!(n%i)) {",
		  "            ans[i]++;",
		  "            n/=i;",
		  "        }",
		  "    if (n>1) ans[n]++;",
		  "    return ans;",
		  "}"
		],
		"description": "Prime factorisation"
	  },
	
	"Euclidean GCD": {
		"prefix": "maths_gcd",
		"body": [
		  "ll gcd(ll a, ll b) { //O(log(min(a,b)))",
		  "    if (!a) return b;",
		  "    if (a>b) swap(a,b);",
		  "    return gcd(b%a, a);",
		  "}"
		],
		"description": "Euclidean GCD"
	},
	//------------------

	"Monotone Deque": {
		"prefix": "stl_monotone_deque",
		"body": [
		  "template <class T>",
		  "struct monotone_deque {",
		  "    deque<T> dq;",
		  "",
		  "    //O(1) because every element can be deleted once.",
		  "    void insert(T k) { //O(k) ... O(1) amourtized",
		  "        while (!dq.empty() && dq.back()>k) ",
		  "            dq.pop_back();",
		  "        dq.push_back(k);",
		  "    }",
		  "",
		  "    void erase(T k) {  //O(1)",
		  "        if (dq.front() == k)",
		  "            dq.pop_front();",
		  "    }",
		  "",
		  "    int min() {  //O(1)",
		  "        if (!dq.empty())",
		  "            return dq.front();",
		  "        else return INT_MIN;",
		  "    }",
		  "};"
		],
		"description": "Monotone Deque"
	},

	"Indexed set (PBDS)": {
  		"prefix": "stl_indexed_set",
  		"body": [
			"/*https://codeforces.com/blog/entry/88193",
			"order_of_key: The number of items in a set that are strictly smaller than k",
			"find_by_order: It returns an iterator to the ith largest element*/",
	    	"#include <ext/pb_ds/assoc_container.hpp>",
	    	"using namespace __gnu_pbds;",
	    	"typedef tree<int, null_type, less<int>, rb_tree_tag,",
	    	"             tree_order_statistics_node_update>",
    		"    indexed_set;",
			"//using less_equal for multiset (but problem for erasing use ",
			"//st.erase(st.upper_bound(ele)) -> erases one instance of the ",
			"//element in the multiset."
  		],
  		"description": "Indexed set (PBDS)"
	},
	"Next greatest element": {
		"prefix": "stl_ngi",
		"body": [
		  "stack<int> st_index;",
		  "int ngi[n];",
		  "for (int i = n-1; i>=0; i--) { //O(n)",
		  "    while (!st_index.empty() && arr[st_index.top()] <= arr[i])",
		  "        st_index.pop();",
		  "    if (st_index.empty())",
		  "        ngi[i] = n;",
		  "    else ngi[i] = st_index.top();",
		  "    st_index.push(i);",
		  "}"
		],
		"description": "Next greatest element (Monotone stack)"
	  },
	  //------------------

	  "Binary search basic": {
		"prefix": "bin_search_basic",
		"body": [
		  "ll lo=0, hi=_upper_limit_, ans=_default_value_;",
		  "while (hi>=low) {",
		  "    ll mid=(lo+hi)/2;",
		  "    if (check(arr, mid)) {",
		  "        ans=mid;",
		  "        hi=mid-1;",
		  "    } else lo=mid+1;",
		  "}"
		],
		"description": "Binary search basic"
	  },
	
	  "Two pointer (from start)": {
		"prefix": "bin_two_pointers_1",
		"body": [
		  "int head=-1, tail=0; //Start from beginning, both pointers should move forward only",
		  "__ds__",
		  "int ans=0;",
		  "while (tail<n) {",
		  "    while (head+1<n && __condition_for_head_to_move_forward__) {",
		  "        head++;",
		  "        __do_something_on_ds__",
		  "    }",
		  "    ans=__update_ans__;",
		  "",
		  "    if (head>=tail) { ",
		  "        __do_reset_something_on_ds__",
		  "        tail++;",
		  "    } else {",
		  "        tail++;",
		  "        head=tail-1;",
		  "    }",
		  "}"
		],
		"description": "Two pointer (from start)"
	  },
	
	  "Ternary Search": {
		"prefix": "bin_ternary_search",
		"body": [
		  "ll lo = 0, hi = a/b; //Can be used for ld",
		  "while (hi-lo>3) { ",
		  "    ll mid1 = (lo*2+hi)/2;",
		  "    ll mid2 = (lo+hi*2)/2;",
		  "",
		  "    if (func(mid1)>func(mid2))  //For Minima",
		  "        lo= mid1;",
		  "    else hi = mid2;",
		  "}",
		  "ld ans=a;",
		  "for (ll i=lo; i<=hi; i++) //Searching the least (integral)",
		  "    ans = min(ans, func(i));"
		],
		"description": "Ternary Search"
	  },

	  "Binary search (Real domain)": {
		"prefix": "bin_real_domain",
		"body": [
		  "ld lo=0.0, hi=__upper_limit__, ans=0.0;",
		  "while (abs(lo-hi)>1e-9) { //__threshold_accuracy__",
		  "    ld mid=(lo+hi)/2.0;",
		  "    if (check(mid)) {",
		  "        ans=mid;",
		  "        lo=mid;",
		  "    }else hi=mid;",
		  "}",
		  "cout << fixed<<setprecision(6)<<ans<< endl;"
		],
		"description": "Binary search (Real domain)"
	  },

	  "Two pointers (Both sided)": {
		"prefix": "bin_two_pointers_2",
		"body": [
		  "int i=0, k=n-1; //Left and right pointers move forward only (-> and <- resp.)",
		  "while (i<j && j<k) { //Condition for stopping (eg. 3_sum problem)",
		  "    if (arr[i]+arr[j]+arr[k]==T) {",
		  "        int itemp=i;                            //",
		  "        int ktemp=k;                            //",
		  "        while (itemp<j && arr[itemp]==arr[i])   //",
		  "            itemp++;                            // Do something here",
		  "        while (ktemp>k && arr[ktemp]==arr[k])   //",
		  "            ktemp--;                            //",
		  "        cnt+=(itemp-i)*(k-ktemp);               // Update DS",
		  "        i=itemp;        ",
		  "        k=ktemp;",
		  "    } else if (arr[i]+arr[j]+arr[k]<T)          //Condition to move left pointer",
		  "        i++;",
		  "    else k--;                                   //Right one",
		  "}"
		],
		"description": "Two pointers (Both sided)"
	  },

	  "Two pointer debug": {
		"prefix": "bin_debug_two_pointer",
		"body": [
		  "for (int i=0;i<n;i++) {",
		  "    if (i==head && head==tail) cout << '*';",
		  "    else if (i==head) cout << 'O';",
		  "    else if (i==tail) cout << '.';",
		  "    else cout << ' ';",
		  "    cout << '\\t';",
		  "}",
		  "cout << endl;",
		  "for (int i=0;i<n;i++)",
		  "    cout << s[i]<<'\\t';",
		  "cout << endl;"
		],
		"description": "Two pointer debug"
	  },
	  //---------------

	  "Basic bitwise functions": {
		"prefix": "bit_basic",
		"body": [
		  "//(Not in-place)",
		  "#define setbit(n,i) ((n)|(1LL<<(i)))       //Add element to the set",
		  "#define unset(n,i) ((n)&(~(1LL<<(i))))  //Remove element",
		  "#define check(n,i) (((n)>>(i))&1LL)       //Is present?",
		  "#define flip(n,i) ((n)^(1LL<<(i)))",
		  "#define flipall(n,i) ((n)^(~0LL))",
		  "//__builtinpopcount(x) -> Set bits  //Cardinality",
		  "//__builtinctz(x) -> Trailing zeros",
		  "//__builtinclz(x) -> Leading zeros",
		  "",
		  "#define remove_last_setbit(n) ((n)&(n-1))",
		  "#define get_last_setbit(n) ((n)&(~(n-1)))",
		  "/*",
		  "0. Set manipulations",
		  "1. X^Y=(X|Y)-(X&Y)",
		  "2. A|B + A&B = A+B",
		  "Categories: Highest to lowest bit, Cyclic order of bits, Bitwise contribution",
		  "*/"
		],
		"description": "Basic bitwise functions"
	  },
	  //------------------

	  "Sieve of eratosthenes": {
		"prefix": "maths_sieve_basic",
		"body": [
		  "//Sieve of eratosthenes",
		  "vector<bool> get_prime_sieve(ll n) {//O(nloglogn)",
		  "    vector<bool> is_prime(n+1, true); ",
		  "    is_prime[0]=is_prime[1]=false;",
		  "    for (ll i=2;i<=n;i++)",
		  "        if (is_prime[i])",
		  "            for (ll j=i*i; j<=n; j+=i)",
		  "                is_prime[j]=false;",
		  "    return is_prime;",
		  "}"
		],
		"description": "Sieve of eratosthenes"
	  },

	  "Get primes upto some integer": {
		"prefix": "maths_primes_upto",
		"body": [
		  "vector<ll> get_primes_upto(ll n) {//O(nloglogn)",
		  "    vector<ll> vc;",
		  "    vector<bool> is_prime(n+1, true); ",
		  "    is_prime[0]=is_prime[1]=false;",
		  "    for (ll i=2;i<=n;i++)",
		  "        if (is_prime[i]) {",
		  "            vc.push_back(i);",
		  "            for (ll j=i*i; j<=n; j+=i)",
		  "                is_prime[j]=false;",
		  "        }",
		  "    return vc;",
		  "}"
		],
		"description": "Get primes upto some integer"
	  },

	  "Segmented sieve": {
		"prefix": "maths_sieve_segmented",
		"body": [
		  "//0->a, b-a->b",
		  "vector<bool> get_segmented_sieve(ll a, ll b) {//O((b-a)loglogb)",
		  "    vector<bool> is_prime(b-a+1, true); //0->l, b-a->r",
		  "    for (ll i:get_primes_upto(sqrt(b))) {",
		  "        for (ll j=max(i*i, (a+i-1)/i*i); j<=b;j+=i)",
		  "            is_prime[j-a]=false;",
		  "    }",
		  "    return is_prime;",
		  "}"
		],
		"description": "Segmented sieve"
	  },

	  "Get primes between a and b": {
		"prefix": "maths_primes_between",
		"body": [
		  "vector<ll> get_primes_between(ll a, ll b) {//O((b-a)loglogb)",
		  "    vector<ll> ans;",
		  "    auto _sieve=get_segmented_sieve(a,b);",
		  "    for (int i=0;i<=b-a;i++)",
		  "        if (_sieve[i]) ans.push_back(i+a);",
		  "    return ans;",
		  "}"
		],
		"description": "Get primes between a and b"
	  },

	  "Fast factorization": {
		"prefix": "maths_factorize_fast",
		"body": [
		  "vector<int> sp;",
		  "void gen_sp_array(ll n) { //O(nloglogn)",
		  "    sp.resize(n+1);",
		  "    for (int i=2;i<=n;i++)",
		  "        sp[i]=i;",
		  "    for (int i=2;i<=n;i++) //O(nloglogn)",
		  "        if (sp[i]==i)//is_prime?",
		  "            for (ll j=1LL*2*i; j<=n;j+=i)",
		  "                sp[j]=i;",
		  "}",
		  "",
		  "unordered_map<ll,ll> get_divisors_fast(ll a) { //O(loga)",
		  "    unordered_map<ll,ll> factors;",
		  "    while (a>1) { //log(a)",
		  "        factors[sp[a]]++;",
		  "        a /= sp[a];",
		  "    }",	
		  "    return factors;",
		  "}"
		],
		"description": "Fast factorization"
	  },

	  "Binomial coefficient (Mod M)": {
		"prefix": "maths_binomial_coefficient",
		"body": [
		  "vector<ll> fact, inv_fact;//upto 10^5",
		  "void build_C(int N=100000, ll M=1e9+7) { //O(n)",
		  "    fact.assign(N+1,0); inv_fact.assign(N+1,0);",
		  "    fact[0]=fact[1]=1;",
		  "    for (int i=2;i<=N;i++)",
		  "        fact[i]=(fact[i-1]*i)%M;",
		  "    inv_fact[N]=binexp(fact[N], M-2);",
		  "    for (int i=N; i>=1;i--)",
		  "        inv_fact[i-1]=(i*inv_fact[i])%M;",
		  "}",
		  "",
		  "ll C(ll n, ll r, ll M=1e9+7) { //O(1)",
		  "    if (r>n) return 0;",
		  "    return fact[n]*inv_fact[n-r]%M*inv_fact[r]%M;",
		  "}"
		],
		"description": "Binomial coefficient (Mod M)"
	  },

	  "Power of prime in n factorial": {
		"prefix": "maths_power_of_prime",
		"body": [
		  "ll power_of_prime(ll n, ll p) { //O(logn)",
		  "    ll ans=0;",
		  "    while (n) ans+=(n/=p);",
		  "    return ans;",
		  "}"
		],
		"description": "Power of prime in n factorial"
	  },

	  //--------------------
	  "LLCM framework": {
		"prefix": "rec_backtracking_framework",
		"body": [
		  "/*",
		  "The LCCM framework for backtracking.",
		  "Choose the DS used to store the current configuration.",
		  "O(ch1*ch2......*chn*(Base recursion complexity + sum(all checks)))",
		  "L - Level",
		  "C - Choice",
		  "C - Check function (For checking the validity of the choice)",
		  "M - Move (Change config., Level up and recurse, Restore config.)",
		  "",
		  "void rec(T lvl)",
		  "    __breaking_condition__ //Base case where answer is updated",
		  "    for (all choices)",
		  "        check(choice)",
		  "        move(lvl+1)",
		  "*/"
		],
		"description": "LLCM framework"
	  },
	  "Merge Sort": {
		"prefix": "rec_mergesort",
		"body": [
		  "vector<int> mergesort(vector<int> &arr) { //O(nlogn)",
		  "    int n=arr.size();",
		  "    if (n==1) return arr;",
		  "    vector<int> ans;ans.resize(n);",
		  "    vector<int> p[2];",
		  "    for (int i=0;i<n;i++) p[i&1].push_back(arr[i]);",
		  "",
		  "    // for (int i=0;i<n/2;i++)p[0].push_back(arr[i]);",
		  "    // for (int i=n/2;i<n;i++)p[1].push_back(arr[i]);",
		  "",
		  "    vector<int> s1=mergesort(p[0]), s2=mergesort(p[1]);",
		  "    int i=0,j=0,k=0;",
		  "    while (i<s1.size() && j<s2.size()) {",
		  "        if (s1[i]<=s2[j])",
		  "            ans[k++]=s1[i++];",
		  "        else ans[k++]=s2[j++];",
		  "    }",
		  "    while (i<s1.size()) ans[k++]=s1[i++];",
		  "    while (j<s2.size()) ans[k++]=s2[j++];",
		  "    return ans;",
		  "}"
		],
		"description": "Merge Sort"
	  },
	  //Meet in the middle(4sum,Subset problems,...), 
	  //DnC(MergeSort, non-overlapping subproblems), Recursion, Backtracking
	  //----------------------

	  //Graphs Algorithms
	  /*
	  For G(V,E) E={(a,b,[w])...}, V={x_i} (indexed)

	  Basic terminology:
	  Directed/undirected, sparse, dense, in/out degree, weighted/unweighted,
	  Sparse/Dense, Path, Isolated node, reachability, CC, SCC, Multigraphs, 
	  DAG, Subgraph (Vertex/edge induced), Trees, Forest, complete graph,
	  Bipartite, binary tree, spanning tree, Eulerian path/Hamiltonian path.

	  Representation: Nodes->indexed
	  	Adjacency list, 
	  	Adjacency matrix (for unweighted consists of 0/1 and symmetric), 
	  	Edge list

	  Using DFS: Cycle detection, bipartite, connected components, 
	  */
	  "Adjancency list input": {
		"prefix": "graph_input_adjacency_list",
		"body": [
		  "vector<vector<int>> g;",
		  "vector<bool> vis;",
		  "int n,m; cin>>n>>m;",
		  "g.resize(n+1);",
		  "for (int i=0;i<m;i++) {",
		  "    int a, b;",
		  "    cin>>a>>b; //If directed -> Assumed a to b (in edge list)",
		  "    g[a].push_back(b);",
		  "    g[b].push_back(a); //If undirected",
		  "}",
		  "vis.assign(n+1,0);"
		],
		"description": "Adjancency list input"
	  },
	  "Basic DFS Outline": {
		"prefix": "graph_dfs_basic",
		"body": [
		  "void dfs(node x) {",
		  "    // Mark node x as visited.",
		  "    // Do some operation on the node like coloring, component id...",
		  "    for (node neighbour:adj_list[x])",
		  "        if (Not marked visited)",
		  "            dfs(neighbour);",
		  "}"
		],
		"description": "Basic DFS Outline"
	  },
	  "BFS Template (Unweighted)": {
		"prefix": "graph_bfs_basic",
		"body": [
		  "using state=pair<int,int>;",
		  "vector<vector<int>> dis; //Unordered map <node,int> basically, default values-INF",
		  "vector<vector<bool>> vis;",
		  "",
		  "vector<state> get_neighbours(state node) {",
		  "    //Fill in",
		  "}",
		  "",
		  "void bfs(state st_node) {//O(|V|+|E|)=O(n+m)",
		  "    queue<state> q;",
		  "    dis[st_node.F][st_node.S]=0;",
		  "    q.push(st_node);",
		  "    while (!q.empty()) {",
		  "        auto tp=q.front();",
		  "        q.pop();",
		  "",
		  "        if (vis[tp.F][tp.S])continue;",
		  "        vis[tp.F][tp.S]=1;",
		  "",
		  "        for (auto &k:get_neighbours(tp)) {",
		  "            if (dis[k.F][k.S]>dis[tp.F][tp.S]+1) { //Relax the edge",
		  "                dis[k.F][k.S]=dis[tp.F][tp.S]+1;",
		  "                q.push(k);",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "BFS Template (Unweighted) - Level Order Traversal"
	  },
	  "Multisource BFS": {
		"prefix": "graph_bfs_multisource",
		"body": [
		  "/*",
		  "MSSP: Supernode concept",
		  "Push all the nodes/sources in the normal BFS in the begining.",
		  "Works with weighted graph algo as well.",
		  "*/"
		],
		"description": "Multisource BFS"
	  },
	  "Cycle detection": {
		"prefix": "graph_cycle_detect",
		"body": [
		  "vector<int> col;",
		  "bool is_cycle=0;",
		  "",
		  "// vector<int> cntcycle; //For counting number of cycles in which a node is involved",
		  "// vector<int> prefix_order;",
		  "",
		  "void dfs(int node, int p) {",
		  "    col[node]=2; //mark it visited",
		  "    for (auto v:g[node]) {",
		  "        //if (v==p) continue; //necessary for undirected",
		  "        if (col[v]==1) {",
		  "            //node -> v: is a forward edge",
		  "            dfs(v, node);",
		  "        } else if (col[v]==2) { //back edge",
		  "            // cntcycle[node]++;",
		  "            // cntcycle[par[v]]--;",
		  "            is_cycle=true;",
		  "        } else if (col[v]==3) { //cross edge",
		  "",
		  "        }",
		  "    }",
		  "    col[node]=3; //all edges explored connecting to it",
		  "    // prefix_order.push_back(node); //Do the prefix sum in the order, in which DFS traverses",
		  "}"
		],
		"description": "Cycle detection"
	  },
	  "Topological ordering - Khan algorithm ": {
		"prefix": "graph_topo_khan",
		"body": [
		  "vector<int> indeg; //outdeg; //__Put in start__ indeg.assign(n+1, 0);",
		  "/* //Put where edge list input is taken ",
		  "indeg[b]++; ",
		  "outdeg[a]++;",
		  "*/",
		  "",
		  "vector<int> topo;",
		  "void kahn() { //O((m+n)) -> *logn when pq is used",
		  "    queue<int> q; //Use priority queue for lexiographically lowest topo ordering...",
		  "                    //Max heap -> Use - for min heap to get lowest node with in-deg =0 always",
		  "    for (int i=1;i<=n;i++)",
		  "        if (indeg[i]==0)",
		  "            q.push(i);",
		  "    while (!q.empty()) {",
		  "        int cur=q.front();",
		  "        q.pop();",
		  "        topo.push_back(cur);",
		  "        for (auto v:g[cur]) {",
		  "            indeg[v]--;",
		  "            if (indeg[v]==0)q.push(v);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Topological ordering - Khan algorithm "
	  },
	  "0/1 BFS": {
		"prefix": "graph_bfs_01",
		"body": [
		  "vector<int> dist;",
		  "vector<bool> vis;",
		  "",
		  "void BFS01(int sc) {",
		  "    deque<int> q;",
		  "    ",
		  "    dist[sc]=0;",
		  "    q.push_back(sc);",
		  "",
		  "    while (!q.empty()) {",
		  "        int cur=q.front();",
		  "        q.pop_front();",
		  "",
		  "        if (vis[cur]) continue;",
		  "        vis[cur]=1;",
		  "",
		  "        for (auto v:g[cur]) {",
		  "            if (dist[v.F]>dist[cur]+v.S) { //Relax the edge",
		  "                dist[v.F]=dist[cur]+v.S;",
		  "                if (v.S) q.push_back(v.F);",
		  "                else q.push_front(v.F);",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "0/1 BFS"
	  },
	  "Component find using DFS": {
		"prefix": "graph_components_find",
		"body": [
		  "void dfs(int x,vector<vector<int>> &g, vector<int> &comp, vector<bool> &vis) {",
		  "    vis[x]=1;",
		  "    comp.push_back(x);",
		  "    for (auto &v:g[x])",
		  "        if (!vis[v]) dfs(v,g,comp,vis);",
		  "}",
		  "vector<vector<int>> get_chunks(vector<vector<int>> &g) { //O(n+m)",
		  "    int n=g.size()-1;",
		  "    vector<vector<int>> ans;",
		  "    vector<bool> vis;vis.assign(n,0);",
		  "    for (int i=1;i<=n;i++) {",
		  "        if (!vis[i]) {",
		  "            vector<int> comp;",
		  "            dfs(i,g,comp,vis);",
		  "            ans.push_back(comp);",
		  "        }",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "Component find using DFS"
	  },
	  
	  /*
	  IMPORTANT: Formulation->Algo->Code
	  Formulation (..)
	  	-> Node:: Stores the state/configuration - Accounts for any constrains
	  	-> Edge weights:: Stores the parameter that needs to optimized.
	  */
	  "No of minimum paths": {
		"prefix": "graph_bfs_number_of_min_paths",
		"body": [
		  "/* ",
		  "Add",
		  "no_of_paths[v]=no_of_paths[ts] in relaxing condition",
		  "and no_of_paths[v]+=no_of_paths[ts] in == condition",
		  "To backtrack each path, ",
		  "use vector<int, vector<int>> pars; To store shortest path parents.",
		  "*/"
		],
		"description": "No of minimum paths"
	  },
	  "Dijkstra algorithm (For non-negative weights/Doesnt work for loop with -ve edges)": {
		"prefix": "graph_dijkstra",
		"body": [
		  "class prioritize {",
		  "    public: bool operator() (ii &p1, ii &p2) {",
		  "        return p1.S>p2.S; //Descending order -> Always choose min distant node",
		  "    }",
		  "};",
		  "",
		  "//vector<vector<pii>> g; Graph like this",
		  "vector<lli> dist;",
		  "vector<bool> vis;",
		  "",
		  "void dikstra(int sc) {",
		  "    dist.assign(n+1, 1e18);",
		  "    vis.assign(n+1,0);",
		  "    dist[sc]=0;",
		  "    priority_queue<pii, vector<pii>, prioritize> q;",
		  "    q.push(MP(sc,0));",
		  "",
		  "    while (!q.empty()) {",
		  "        pii fs=q.top(); q.pop();",
		  "",
		  "        if (vis[fs.F]) continue;",
		  "        vis[fs.F]=1;",
		  "",
		  "        for (auto v:g[fs.F]) {",
		  "            int neigh=v.F, wt=v.S;",
		  "            if (dist[neigh]>dist[fs.F]+wt) { //relax",
		  "                dist[neigh]=dist[fs.F]+wt;",
		  "                q.push({neigh, dist[neigh]});",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Dijkstra algorithm (For non-negative weights)"
	  },
	  "Bellman Ford (Works for real weights)": {
		"prefix": "graph_bellman_ford",
		"body": [
		  "vector<pair<ii,int>> g; //edge-list (a->b,w)",
		  "vector<ll> dist; //Set starting node distance as 0 dist[1]=0; and resize accordingly",
		  "vector<bool> vis;",
		  "bool neg_cyc=false;",
		  "for (int i=0;i<n;i++) { //O(|V|.|E|)=O(nm)",
		  "    for (auto e:g) {",
		  "        if (dist[e.F.S]>dist[e.F.F]+e.S) { //relax",
		  "            dist[e.F.S]=dist[e.F.F]+e.S;",
		  "            if (i==n-1) neg_cyc=true;",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Bellman Ford (Works for real weights)"
	  },
	  "Floyd Warshall (Use-Query,Transitive closure(x->y), Min cycle length from X, -ve cycle detection, diameter)": {
		"prefix": "graph_apsp_floyd_warshall",
		"body": [
		  "int n,m;",
		  "int dist[404][404]; //adj matrix",
		  "int par[404][404];",
		  "",
		  "// ( i->x->y ... -> par[i][j] ) -> j",
		  "void print_path(int i, int j) {",
		  "    if (i!=j) print_path(i, par[i][j]);",
		  "    cout << j << endl;",
		  "}",
		  "",
		  "signed main() {",
		  "    IOS cin>>n>>m;",
		  "    for (int i=0;i<n;i++)",
		  "        for (int j=0;j<n;j++)",
		  "            if (i!=j)dist[i][j]=1e9;",
		  "    for (int i=0;i<m;i++) {",
		  "        int a,b,c; cin>>a>>b>>c;",
		  "        dist[a][b]=min(dist[a][b],c);",
		  "    }",
		  "    ",
		  "    for (int i=0;i<n;i++) {",
		  "        for (int j=0;j<n;j++) {",
		  "            par[i][j]=i;",
		  "        }",
		  "    }",
		  "    // i->x->y ... -> par[i][j] -> j",
		  "    for (int k=0;k<n;k++) { //O(n^3)",
		  "        for (int i=0;i<n;i++) {",
		  "            for (int j=0;j<n;j++) {",
		  "                if (dist[i][j]>dist[i][k]+dist[k][j]) { //When relaxed...",
		  "                    dist[i][j]=dist[i][k]+dist[k][j];",
		  "                    par[i][j]=par[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Floyd Warshall"
	  },
	  "Articulation point/Bridges (Tarjan's algo)": {
		"prefix": "graph_articulation_point",
		"body": [
		  "vector<bool> vis;",
		  "vector<int> tin,tlow;",
		  "unordered_set<int> art_pt;",
		  "int timer;",
		  "",
		  "void dfs(int i, int p=-1) {",
		  "    vis[i]=1;",
		  "    tin[i]=tlow[i]=timer++;",
		  "    int children=0;",
		  "    for (auto v:g[i]) {",
		  "        if (v==p) continue;",
		  "        if (vis[v]) //back-edge",
		  "            tlow[i]=min(tlow[i], tin[v]);",
		  "        else {",
		  "            dfs(v, i);",
		  "            tlow[i]=min(tlow[i], tlow[v]);",
		  "            if (tlow[v]>=tin[i] && p!=-1) //Strict comparison for bridges and remove p!=-1",
		  "                art_pt.insert(v);",
		  "            children++;",
		  "        }",
		  "    }",
		  "    if (p==-1 && children>1)",
		  "        art_pt.insert(i);",
		  "}"
		],
		"description": "Articulation point"
	  },
	  "Articulation point (With extra components find)": {
		"prefix": "graph_articulation_point_extra",
		"body": [
		  "vector<bool> vis;",
		  "vector<int> tin, low;",
		  "int timer;",
		  "",
		  "vector<int> extra; //Stores extra components when node is removed",
		  "void dfs(int nn, int pp) {",
		  "    vis[nn]=1;",
		  "    tin[nn]=low[nn]=timer++;",
		  "",
		  "    vector<int> chnodes;",
		  "    int child=0;",
		  "    for (auto v:g[nn]) {",
		  "        if (v==pp) continue;",
		  "        if (vis[v]) { //backedge",
		  "            low[nn]=min(low[nn], tin[v]);",
		  "        } else {",
		  "            chnodes.push_back(v);",
		  "            dfs(v, nn);",
		  "            low[nn]=min(low[nn], low[v]);",
		  "            child++;",
		  "        }",
		  "    }",
		  "    if (pp==0) { //root node",
		  "        extra[nn]=child-1; //",
		  "    } else {",
		  "        for (auto v:chnodes) {",
		  "            if (low[v]>=tin[nn]) { //Strict comparison for bridges",
		  "                //this v child will lead to new comp",
		  "                extra[nn]++;",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Articulation point (With extra components find)"
	  },
	  "Union Find": {
		"prefix": "graph_union_find",
		"body": [
		  "class UnionFind {",
		  "private:",
		  "    int n,set_size, *parent, *rank;",
		  "public:",
		  "    UnionFind(){}",
		  "    UnionFind(int a) { //a: set size, {1,2...n}",
		  "        n=set_size=a;",
		  "        parent=new int[n+1];",
		  "        rank=new int[n+1];",
		  "        for (int i=1;i<=n;i++) parent[i]=i, rank[i]=1;",
		  "    }",
		  "",
		  "    int find(int x) { //O(A(n))",
		  "        if (x!=parent[x]) return parent[x]=find(parent[x]); //path-compression",
		  "        return x;",
		  "    }",
		  "",
		  "    bool merge(int x, int y) { //O(A(n))",
		  "        int xroot=find(x), yroot=find(y);",
		  "        if (xroot!=yroot) { //rank-compression",
		  "            if (rank[xroot]>=rank[yroot]) {",
		  "                parent[yroot]=xroot;",
		  "                rank[xroot]+=rank[yroot];",
		  "            } else {",
		  "                parent[xroot]=yroot;",
		  "                rank[yroot]+=rank[xroot];",
		  "            }",
		  "            set_size--;",
		  "            return 1;",
		  "        }",
		  "        return 0;",
		  "    }",
		  "",
		  "    void reset() {",
		  "        set_size=n;",
		  "        for (int i=1;i<=n;i++) parent[i]=i, rank[i]=1;  ",
		  "    }",
		  "};"
		],
		"description": "Union Find"
	  },
	  "Krushkal's algorithm": {
		"prefix": "graph_mst_krushkal",
		"body": [
		  "UnionFind uf(n);",
		  "",
		  "vector<pair<int,ii>> edge_list;",
		  "int a,b,c;",
		  "for (int i=0;i<m;i++) {",
		  "    cin>>a>>b>>c;",
		  "    edge_list.push_back({c,{a,b}});",
		  "}",
		  "sort(edge_list.begin(), edge_list.end());",
		  "",
		  "int mst_cost=0;",
		  "for (auto v:edge_list) {",
		  "    int x=v.S.F, y=v.S.S;",
		  "    if (uf.find(x)!=uf.find(y)) {",
		  "        mst_cost+=v.first;",
		  "        uf.merge(x,y);",
		  "    }",
		  "}",
		  "cout << mst_cost << endl;"
		],
		"description": "Krushkall's algorithm"
	  },
	  "Union Find with rollback": {
  "prefix": "graph_union_find_rollback",
  "body": [
    "class UnionFind {",
    "private:",
    "    int n,set_size, *parent, *rank;",
    "    stack<pair<int,pair<int,int>>> st;",
    "public:",
    "    UnionFind(){}",
    "    UnionFind(int a) { //a: set size, {1,2...n}",
    "        n=set_size=a;",
    "        parent=new int[n+1];",
    "        rank=new int[n+1];",
    "        for (int i=1;i<=n;i++) parent[i]=i, rank[i]=1;",
    "    }",
    "",
    "    int find(int x) { //O(logn)",
    "        if (x!=parent[x]) return find(parent[x]);",
    "        return x;",
    "    }",
    "",
    "    bool merge(int x, int y) { //O(logn)",
    "        int xroot=find(x), yroot=find(y);",
    "        if (xroot!=yroot) { //rank-compression",
    "            if (rank[xroot]>=rank[yroot]) {",
    "                st.push({yroot,{parent[yroot],rank[xroot]}});",
    "                parent[yroot]=xroot;",
    "                rank[xroot]+=rank[yroot];",
    "            } else {",
    "                st.push({xroot,{parent[xroot],rank[yroot]}});",
    "                parent[xroot]=yroot;",
    "                rank[yroot]+=rank[xroot];",
    "            }",
    "            set_size--;     ",
    "            return 1;",
    "        }",
    "        return 0;",
    "    }",
    "",
    "    bool rollback() { //O(1)",
    "        if (st.empty()) return 0;",
    "        auto &his=st.top();",
    "        rank[parent[his.first]]=his.second.second;",
    "        parent[his.first]=his.second.first;",
    "        st.pop();",
    "        set_size++;",
    "        return 1;",
    "    }",
    "",
    "    void reset() {",
    "        set_size=n;",
    "        for (int i=1;i<=n;i++) parent[i]=i, rank[i]=1;  ",
    "    }    ",
    "};"
  ],
  "description": "Union Find with rollback"
},

"Tree implementation": {
  "prefix": "tree_basics",
  "body": [
    "vector<vector<int>> g; //|E|=|V|-1 and 1CC",
    "vector<int> dep, par, subtree_sz, numChild;",
    "vector<bool> is_leaf;",
    "",
    "//No need for visited array, since there are no cycles, all nodes are visited only once.",
    "void dfs(int node, int parent, int depth) {",
    "    dep[node]=depth;",
    "    par[node]=parent;",
    "",
    "    subtree_sz[node]=1;",
    "    numChild[node]=0; ",
    "    for (auto v:g[node]) {",
    "        if (v!=parent) { //inside the subtree",
    "            numChild[node]++;",
    "            dfs(v, node, depth+1);",
    "            subtree_sz[node]+=subtree_sz[v];",
    "        }",
    "    }",
    "    if (!numChild[node])",
    "        is_leaf[node]=1;",
    "}"
  ],
  "description": "Tree implementation"
},

"Tree diameter": {
  "prefix": "tree_diameter",
  "body": [
    "//Place outside",
    "void dotree(int node, int parent, int depth, vector<vector<int>>&g,vector<int>&dep,vector<int>&par) {",
    "    dep[node]=depth;",
    "    par[node]=parent;",
    "    for (auto v:g[node]) if (v!=parent)",
    "        dotree(v, node, depth+1,g,dep,par);",
    "}",
    "",
    "//Diameter",
    "vector<int> dep, par; dep.resize(n); par.resize(n);",
    "dotree(0,-1,0,g,dep,par);",
    "int max_dep_node=0;",
    "for (int i=0;i<n;i++) if (dep[i]>dep[max_dep_node])max_dep_node=i;",
    "dotree(max_dep_node,-1,0,g,dep,par);",
    "max_dep_node=0;",
    "for (int i=0;i<n;i++) if (dep[i]>dep[max_dep_node])max_dep_node=i;",
    "int dia=dep[max_dep_node];",
    "",
    "//Centres",
    "vector<int> ans;",
    "int node_=max_dep_node;",
    "for (int i=0;i<dia/2;i++)node_=par[node_];",
    "ans.push_back(node_);",
    "if (dia&1) ans.push_back(par[node_]);"
  ],
  "description": "Tree diameter"
},

"Tree centroid": {
  "prefix": "tree_centroid",
  "body": [
    "int get_centroid(int node, int parent) {",
    "    for (auto v:g[node])",
    "        if (v!=parent)",
    "            if (subtree_sz[v]>n/2)",
    "                return get_centroid(v, node);",
    "    return node;",
    "}"
  ],
  "description": "Tree centroid"
},

"Kosaraju's algorithm": {
  "prefix": "graph_scc_condense",
  "body": [
    "vector<vector<int>> g, grev; //Construct the graph and its reverse graph",
    "vector<int> vis(100100,0);",
    "vector<int> tout_order;",
    "void dfs1(int x) {",
    "    vis[x]=1;",
    "    for (auto v:g[x]) {",
    "        if(!vis[v])        ",
    "            dfs1(v);",
    "    }",
    "    tout_order.push_back(x);",
    "}",
    "int cur_scc=0;",
    "int scc_num[100100];",
    "void dfs2(int x) {",
    "    scc_num[x]=cur_scc;",
    "    vis[x]=1;",
    "    for (auto v:grev[x])",
    "        if (!vis[v])",
    "            dfs2(v);",
    "}",
    "vector<vector<int>> condensed_graph;",
    "",
    "void condense() {",
    "    for (int i=1;i<=n;i++)",
    "        if (!vis[i])",
    "            dfs1(i);",
    "    reverse(tout_order.begin(), tout_order.end());",
    "    vis.assign(n+1,0);",
    "    for (auto x:tout_order)",
    "        if (!vis[x]) {",
    "            cur_scc++;",
    "            dfs2(x);",
    "        }",
    "    ",
    "    condensed_graph.resize(cur_scc+1); //Use vector<unordered<set<int>> condensed_graph //for no multi-edge.",
    "    for (int i=1;i<=n;i++) {",
    "        for (auto v:g[i]) {",
    "            if (scc_num[i]!=scc_num[v]) //belongs to other scc",
    "                condensed_graph[scc_num[i]].push_back(scc_num[v]);",
    "        }",
    "    }",
    "}"
  ],
  "description": "Kosaraju's algorithm"
},

//-------------------

/*
DP::
Identify form -> State space formulation -> Transition design -> TC -> CoDE!
*/
"DP Basic structure": {
  "prefix": "dp_basic_template",
  "body": [
    "int dp[...][...][...];",
    "__DS__ rec(__form_state__, __aggregates__) {",
    "    //pruning",
    "",
    "    //base_case",
    "",
    "    //cache check",
    "",
    "    //transition",
    "",
    "    //save and return",
    "}"
  ],
  "description": "DP Basic structure"
},

"Basic template 2": {
  "prefix": "template_basic_2",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "#define endl '\\n'",
    "//using ll=int64_t;",
	"#define int long long",
    "",
    "void solve() {",
    "    ",
    "}",
    "",
    "#undef int",
    "int main() {",
    "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
    "    int _t;cin>>_t;while (_t--)",
    "    solve();",
    "}"
  ],
  "description": "Basic template 2"
},

"Basic template 3": {
  "prefix": "template_basic_3",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "#define endl '\\n'",
    "using i64=int64_t;",
    "",
    "inline void solve() {",
    "    ",
    "}",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
    "    int32_t _T;cin>>_T;while (_T--)",
    "    solve();",
    "}"
  ],
  "description": "Basic template 2"
},
//Strings and tries

"Trie Basic ": {
  "prefix": "string_trie",
  "body": [
    "struct node {",
    "    int child[26];",
    "    node(){",
    "        memset(child,-1,sizeof(child)); //null",
    "    }",
    "};",
    "",
    "struct trie {",
    "    vector<node> nodes;",
    "    trie() {",
    "        node rootnode;",
    "        //fill for root",
    "        nodes.push_back(rootnode);",
    "    }",
    "",
    "    void insert(string s) { //O(n)",
    "        int cur_node_idx=0;",
    "        for (int i=0;i<s.size();i++) {",
    "            if (nodes[cur_node_idx].child[s[i]-'a']==-1) {",
    "                node new_node;",
    "                //change the new node",
    "                nodes.push_back(new_node);",
    "                nodes[cur_node_idx].child[s[i]-'a']=nodes.size()-1;",
    "            }",
    "            cur_node_idx=nodes[cur_node_idx].child[s[i]-'a'];",
    "            //end the string",
    "        }",
    "    }",
    "",
    "    int get_node_count() {",
    "        return nodes.size();",
    "    }",
    "};"
  ],
  "description": "Trie Basic "
},

"KMP algorithm": {
  "prefix": "string_kmp",
  "body": [
    "string s;cin>>s;",
    "int n=s.length(); //string is 0 indexed",
    "int kmp[n+1]; //KMP values are 1 indexed",
    "    ",
    "int i=0,j=-1; kmp[0]=-1;",
    "while (i<n) {",
    "    while (j!=-1 && s[i]!=s[j]) j=kmp[j];",
    "    j++;i++;",
    "    kmp[i]=j;",
    "}"
  ],
  "description": "KMP algorithm (Longest palindrome, Period...)"
},

"Z algorithm": {
  "prefix": "strings_z_algo",
  "body": [
    "vector<int> z_function(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int l = 0, r = 0;",
    "    for(int i = 1; i < n; i++) {",
    "        if(i < r) {",
    "            z[i] = min(r - i, z[i - l]);",
    "        }",
    "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            z[i]++;",
    "        }",
    "        if(i + z[i] > r) {",
    "            l = i;",
    "            r = i + z[i];",
    "        }",
    "    }",
    "    return z;",
    "}"
  ],
  "description": "Z algorithm"
},

"Manacher algorithm": {
  "prefix": "string_manacher",
  "body": [
    "struct manacher {",
    "    vector<int> p; //Each index increased by one, contrary to video...",
    "",
    "    void run_manacher(string s) {",
    "        int n=s.length();",
    "        p.assign(n,1);",
    "        int l=1,r=1;",
    "        for (int i=1;i<n;i++) {",
    "            p[i]=max(0,min(r-i,p[l+r-i]));",
    "            while (i+p[i]<n && i-p[i]>=0 && s[i+p[i]]==s[i-p[i]]) {",
    "                p[i]++;",
    "            }",
    "            if (i+p[i]>r) {",
    "                l=i-p[i];",
    "                r=i+p[i];",
    "            }",
    "        }",
    "    }",
    "",
    "    void build(string s) {",
    "        string t;",
    "        for (auto v:s) t+=string(\"#\")+v;",
    "        run_manacher(t+\"#\");",
    "    }",
    "",
    "    int getLongest(int cen, bool odd) {",
    "        int pos=2*cen+1+(!odd);",
    "        return p[pos]-1;",
    "    }",
    "",
    "    bool isPalindrome(int l, int r) {",
    "        if ((r-l+1)<=getLongest((l+r)/2,l%2==r%2))",
    "            return 1;",
    "        return 0;",
    "    }",
    "};"
  ],
  "description": "Manacher algorithm"
},

"Rolling Hash": {
  "prefix": "string_hasher",
  "body": [
    "ll quickHash(string s, ll p=31, ll mod=999999929) {",
    "    ll ans=s[0]-'a'+1;",
    "    for (int i=1;i<s.length();i++)",
    "        ans=(ans*p+(s[i]-'a'+1))%mod;",
    "    return ans;",
    "}",
    "struct hasher {",
    "    int sz; ll mod,p;",
    "    vector<ll> fHash, rHash;",
    "    vector<ll> pk; //p^( )",
    "    void init(string &s, ll _p=31, ll _mod=999999929) {",
    "        mod=_mod; p=_p;",
    "        sz=s.length();",
    "        fHash.resize(sz); pk.resize(sz);",
    "        fHash[0]=s[0]-'a'+1;",
    "        pk[0]=1;",
    "        for (int i=1;i<s.length();i++) {",
    "            fHash[i]=(fHash[i-1]*p+(s[i]-'a'+1))%mod; ",
    "            pk[i]=pk[i-1]*p%mod;",
    "        }",
    "",
    "        rHash.resize(sz); ",
    "        rHash[sz-1]=s.back()-'a'+1;",
    "        for (int i = sz-2; i >= 0; i--)",
    "            rHash[i] = (rHash[i + 1]*p + (s[i]-'a'+1))%mod;",
    "    }",
    "    ll getfHash(int l, int r) { //s[l...r] = f[r]-f[l-1]*(p^(r-l+1))",
    "        if (l==0) return fHash[r];",
    "        return ((fHash[r]-fHash[l-1]*pk[r-l+1]%mod)%mod+mod)%mod;",
    "    }",
    "    ll getrHash(int l, int r) { ",
    "        if (r==sz-1) return rHash[l];",
    "        return ((rHash[l]-rHash[r+1]*pk[r-l+1]%mod)%mod+mod)%mod;",
    "    }",
    "};",
    "struct dhasher {",
    "    hasher h1,h2;",
    "    ",
    "    void init(string &s, ll p1=31, ll p2=37, ll mod1=999999929, ll mod2=999999937) {",
    "        h1.init(s,p1,mod1);",
    "        h2.init(s,p2,mod2);",
    "    }",
    "    pair<int,int> getfHash(int l, int r) {",
    "        return {h1.getfHash(l,r),h2.getfHash(l,r)};",
    "    }",
    "};"
  ],
  "description": "Rolling Hash"
},

"Bit trie": {
  "prefix": "bit_trie",
  "body": [
    "struct node {",
    "    int child[2];",
    "    int cnt=0;",
    "    node () {",
    "        memset(child,-1,sizeof(child));",
    "    }",
    "};",
    "",
    "#define LN 32",
    "struct bittrie {",
    "    vector<node> nodes;",
    "    bittrie() {",
    "        node root;",
    "        nodes.push_back(root);",
    "    }",
    "",
    "    void insert(ll x) { //O(LN)",
    "        int cur_node=0;",
    "        for (int i=LN-1;i>=0;--i) {",
    "            int v=(x>>i)&1;",
    "            if (nodes[cur_node].child[v]==-1) {",
    "                node new_node;",
    "                nodes.push_back(new_node);",
    "                nodes[cur_node].child[v]=nodes.size()-1;",
    "            }",
    "            nodes[cur_node].cnt++;",
    "            cur_node=nodes[cur_node].child[v];",
    "        }",
    "        nodes[cur_node].cnt++;",
    "    }",
    "",
    "    void erase(ll x) {",
    "        int cur_node=0;",
    "        for (int i=LN-1;i>=0;--i) {",
    "            int v=(x>>i)&1;",
    "            nodes[cur_node].cnt--;",
    "            cur_node=nodes[cur_node].child[v];",
    "        }",
    "        nodes[cur_node].cnt--;",
    "    }",
    "",
    "    ll query(ll x) { //Returns best XOR possible",
    "        ll y=0;",
    "        int cur_node=0;",
    "        for (int i=LN-1;i>=0;--i) {",
    "            int v=(x>>i)&1;",
    "            if (nodes[cur_node].child[!v]!=-1 && nodes[nodes[cur_node].child[!v]].cnt>0) {",
    "                if ((!v)==1) y|=(1ll<<i);",
    "                cur_node=nodes[cur_node].child[!v];",
    "            } else {",
    "                if (v==1) y|=(1ll<<i);",
    "                cur_node=nodes[cur_node].child[v];",
    "            }",
    "        }",
    "        return x^y;",
    "    }",
    "};"
  ],
  "description": "Bit trie"
},

"Lowest common ancestor (LCA)": {
  "prefix": "tree_lca",
  "body": [
    "int n;",
    "vector<int> g[100100];",
    "int depth[100100], parent[100100][20];",
    "",
    "int val[100100];",
    "// int dp[100100][20]; //dp[i][k]= gcd of ancestral chain of i upto k lifts (excluding last node)",
    "",
    "//Building lifting str",
    "void dfs(int node, int par, int dep) { //O(NlogN)",
    "    parent[node][0]=par;",
    "    depth[node]=dep;",
    "    // dp[node][0]=val[node];",
    "    for (int i=1;i<20;i++) {",
    "        parent[node][i]=parent[parent[node][i-1]][i-1];",
    "        // dp[node][i]=__gcd(dp[node][i-1], dp[parent[node][i-1]][i-1]);",
    "    }",
    "    for (auto v:g[node]) {",
    "        if (v!=par) ",
    "            dfs(v,node,dep+1);",
    "    }",
    "}",
    "",
    "int lca(int u, int v) { //O(logN)",
    "    if (depth[u]<depth[v]) swap(u,v);",
    "",
    "    for (int i=19;i>=0;i--) //Bring to the same level",
    "        if ((depth[u]-depth[v])&(1<<i))",
    "            u=parent[u][i];",
    "    if (u==v) return u;",
    "",
    "    for (int i=19;i>=0;i--) { //Jump till parents aren't same",
    "        if (parent[v][i]!=parent[u][i]) {",
    "            v=parent[v][i];",
    "            u=parent[u][i];",
    "        }",
    "    }",
    "    return parent[u][0];",
    "}"
  ],
  "description": "Lowest common ancestor (LCA)"
},

//Segment Trees

"Segment Tree Basic": {
  "prefix": "segtree",
  "body": [
    "int n,q;",
    "int arr[200100];",
    "",
    "int t[800400]; //4*n",
    "",
    "void build(int idx, int l, int r) { ",
    "    if (l==r) { t[idx]=arr[l]; return; }",
    "    int mid=(l+r)/2;",
    "    build(idx*2,l,mid);",
    "    build(idx*2+1,mid+1,r);",
    "    t[idx]=t[2*idx]+t[2*idx+1];",
    "}",
    "",
    "void update(int idx, int l, int r, int pos, int val) {",
    "    if (pos<l||pos>r) return;",
    "    if (l==r) {",
    "        t[idx]=val;",
    "        // arr[l]=val;",
    "        return;",
    "    }",
    "    int mid=(l+r)/2;",
    "    update(idx*2,l,mid,pos,val);",
    "    update(idx*2+1,mid+1,r,pos,val);",
    "    t[idx]=t[2*idx]+t[2*idx+1]; //merge logic",
    "}",
    "",
    "int query(int idx, int l, int r, int lq, int rq) {",
    "    if (l>rq||lq>r) return 0;",
    "    if (lq<=l&&r<=rq) return t[idx];",
    "    int mid=(l+r)/2;",
    "    return query(idx*2,l,mid,lq,rq)+query(idx*2+1,mid+1,r,lq,rq);",
    "}"
  ],
  "description": "Basic template for segment trees & applications."
},

"Segment Trees with Lazy Propagation": {
  "prefix": "segtree_lazy",
  "body": [
    "struct node {",
    "    int sum,maxr,lazy;",
    "    //bool isLazy;",
    "    node(){",
    "        sum=maxr=lazy=0; //marked with 0 means unmarked",
    "    }",
    "};",
    "",
    "node merge(node a, node b) {",
    "    node temp;",
    "    temp.sum=a.sum+b.sum;",
    "    temp.maxr=max(a.maxr,b.maxr);",
    "    return temp;",
    "}",
    "",
    "int n,q;",
    "int arr[200100];",
    "node t[800400]; ",
    "",
    "void push(int idx, int l, int r) {",
    "    if (t[idx].lazy) {",
    "        t[idx].sum=t[idx].lazy*(r-l+1);",
    "        t[idx].maxr=t[idx].lazy;",
    "        if (l!=r) {",
    "            t[idx<<1].lazy=t[idx].lazy;",
    "            t[idx<<1|1].lazy=t[idx].lazy;",
    "        }",
    "        t[idx].lazy=0; //unmark",
    "    }",
    "}",
    "",
    "void update(int idx, int l, int r, int lq, int rq, int v) {",
    "    push(idx,l,r);",
    "    if (lq>r||l>rq) return;",
    "    if (lq<=l&&r<=rq) {",
    "        t[idx].lazy=v;",
    "        push(idx,l,r); //correct the values",
    "        return;",
    "    }",
    "    int mid=(l+r)>>1;",
    "    update(idx<<1,l,mid,lq,rq,v);",
    "    update(idx<<1|1,mid+1,r,lq,rq,v);",
    "    t[idx]=merge(t[idx<<1],t[idx<<1|1]);",
    "}",
    "",
    "node query(int idx, int l, int r, int lq, int rq) {",
    "    push(idx,l,r);",
    "    if (l>rq||lq>r) return node();",
    "    if (lq<=l&&r<=rq) return t[idx];",
    "    int mid=(l+r)>>1;",
    "    return merge(query(idx<<1,l,mid,lq,rq),query(idx<<1|1,mid+1,r,lq,rq));",
    "}"
  ],
  "description": "Segment Trees with Lazy Propagation"
},

"Knapsack merge format": {
  "prefix": "tree_dp_knapsack",
  "body": [
    "int n,k;",
    "vector<int> g[101];",
    "int arr[101];",
    "int sz[101];",
    "int dp[101][2][101];",
    "void dfs(int nn, int pp) { //O(n.k^2) or O(n^3) -> O(n.k)~O(n^2)",
    "    for (int i=0;i<=k;i++) { //leaf",
    "        dp[nn][1][i]=(i==1?arr[nn]:-1e9);",
    "        dp[nn][0][i]=(i==0?0:-1e9);",
    "    }",
    "    sz[nn]=1;",
    "    for (auto v:g[nn]) if (v!=pp) {",
    "        dfs(v,nn);",
    "        // sz[nn]+=sz[v];",
    "",
    "        // for (int a=k;a>=0;a--) for (int b=k;b>=0;b--) { //actually dp2 itself",
    "        //     dp[nn][0][a+b]=max(dp[nn][0][a+b],dp[nn][0][a]+max(dp[v][0][b],dp[v][1][b]));",
    "        //     dp[nn][1][a+b]=max(dp[nn][1][a+b],dp[nn][1][a]+dp[v][0][b]);",
    "        // }",
    "",
    "        //Other faster variation",
    "        for (int a=sz[nn];a>=0;a--) for (int b=sz[v];b>=0;b--) { //actually dp2 itself",
    "            dp[nn][0][a+b]=max(dp[nn][0][a+b],dp[nn][0][a]+max(dp[v][0][b],dp[v][1][b]));",
    "            dp[nn][1][a+b]=max(dp[nn][1][a+b],dp[nn][1][a]+dp[v][0][b]);",
    "        }",
    "        sz[nn]+=sz[v];",
    "    }",
    "}"
  ],
  "description": "Knapsack merge format"
},
"dp_sos": {
  "prefix": "dp_sos",
  "body": [
    "const int N=20;",
    "void forward1(int *dp) { //addition contribution to supersets ",
    "    for (int i=0;i<N;i++) for (int m=0;m<(1<<N);m++) if ((m>>i)&1)",
    "        dp[m]+=dp[m^(1<<i)];",
    "}",
    "void backward1(int *dp) { //undo",
    "    for (int i=0;i<N;i++) for (int m=(1<<N)-1;m>=0;m--) if ((m>>i)&1)   ",
    "        dp[m]-=dp[m^(1<<i)];",
    "}",
    "void forward2(int *dp) { //adding elements to subsets",
    "    for (int i=0;i<N;i++) for (int m=(1<<N)-1;m>=0;m--) if ((m>>i)&1)   ",
    "        dp[m^(1<<i)]+=dp[m];",
    "}",
    "void backward2(int *dp) {",
    "    for (int i=0;i<N;i++) for (int m=0;m<(1<<N);m++) if ((m>>i)&1)",
    "        dp[m^(1<<i)]-=dp[m];",
    "}"
  ],
  "description": "dp_sos"
}

}